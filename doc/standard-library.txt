### `std.version`

`std.version.major`

	* Denotes the major version number of the standard library that
	  has been enabled. This member is always set, even when there is
	  no standard library.

`std.version.minor`

	* Denotes the minor version number of the standard library that
	  has been enabled. This member is always set, even when there is
	  no standard library.

### `std.system`

`std.system.gc_count_variables(generation)`

	* Gets the number of variables that are being tracked by the
	  collector for `generation`. Valid values for `generation` are
	  `0`, `1` and `2`.

	* Returns the number of variables being tracked. This value is
	  only informative.

	* Throws an exception if `generation` is out of range.

`std.system.gc_get_threshold(generation)`

	* Gets the threshold of the collector for `generation`. Valid
	  values for `generation` are `0`, `1` and `2`.

	* Returns the threshold.

	* Throws an exception if `generation` is out of range.

`std.system.gc_set_threshold(generation, threshold)`

	* Sets the threshold of the collector for `generation` to
	  `threshold`. Valid values for `generation` are `0`, `1` and
	  `2`. Valid values for `threshold` range from `0` to an
	  unspecified positive integer; overlarge values are capped
	  silently without failure. A larger `threshold` makes garbage
	  collection run less often but slower. Setting `threshold` to
	  `0` ensures all unreachable variables be collected immediately.

	* Returns the threshold before the call.

	* Throws an exception if `generation` is out of range.

`std.system.gc_collect([generation_limit])`

	* Performs garbage collection on all generations including and
	  up to `generation_limit`. If it is absent, all generations are
	  collected.

	* Returns the number of variables that have been collected in
	  total.

`std.system.env_get_variable(name)`

	* Retrieves an environment variable with `name`.

	* Returns the environment variable's value if a match is found,
	  or `null` if no such variable exists.

	* Throws an exception if `name` is not valid.

`std.system.env_get_variables()`

	* Retrieves all environment variables.

	* Returns an object of strings which consists of copies of all
	  environment variables.

`std.system.uuid()`

	* Generates a UUID according to the following specification:

	  Canonical form: `xxxxxxxx-xxxx-Myyy-Nzzz-wwwwwwwwwwww`

	  * x: number of 1/30,518 seconds since UNIX Epoch
	  * M: always `4` (UUID version)
	  * y: process ID
	  * N: any of `0`-`7` (UUID variant)
	  * z: context ID
	  * w: random bytes

	  Unlike version-1 UUIDs in RFC 4122, the timestamp is written
	  in pure big-endian order. This ensures the case-insensitive
	  lexicographical order of such UUIDs will match their order of
	  creation. Hexadecimal digits above nine are encoded as capital
	  letters.

	* Returns a UUID as a string of 36 characters without braces.

`std.system.proc_get_pid()`

	* Gets the ID of the current process.

	* Returns the process ID as an integer.

`std.system.proc_get_ppid()`

	* Gets the ID of the parent process.

	* Returns the parent process ID as an integer.

`std.system.proc_get_uid()`

	* Gets the real user ID of the current process.

	* Returns the real user ID as an integer.

`std.system.proc_get_euid()`

	* Gets the effective user ID of the current process.

	* Returns the effective user ID as an integer.

`std.system.proc_invoke(cmd, [argv], [envp])`

	* Launches the program denoted by `cmd`, awaits its termination,
	  and returns its exit status. If `argv` is provided, it shall be
	  an array of strings, which specify additional arguments to pass
	  to the program along with `cmd`. If `envp` is specified, it
	  shall also be an array of strings, which specify environment
	  variables to pass to the program.

	* Returns the exit status as an integer. If the process exits due
	  to a signal, the exit status is `128+N` where `N` is the signal
	  number.

	* Throws an exception if the program could not be launched or its
	  exit status could not be retrieved.

`std.system.proc_daemonize()`

	* Detaches the current process from its controlling terminal and
	  continues in the background. The calling process terminates on
	  success so this function never returns.

	* Throws an exception on failure.

`std.system.conf_load_file(path)`

	* Loads the configuration file denoted by `path`. Its syntax is
	  similar to JSON5, except that commas, semicolons and top-level
	  braces are omitted for simplicity, and single-quoted strings do
	  not support escapes. A sample configuration file can be found
	  at 'doc/sample.conf'.

	* Returns an object of all values from the file, if it was parsed
	  successfully.

	* Throws an exception if the file could not be opened, or there
	  was an error in it.

### `std.debug`

`std.debug.logf(templ, ...)`

	* Compose a string in the same way as `std.string.format()`, but
	  instead of returning it, write it to standard error. A line
	  break is appended to terminate the line.

	* Returns the number of bytes written if the operation succeeds,
	  or `null` otherwise.

`std.debug.dump([value], [indent])`

	* Prints the value to standard error with detailed information.
	  `indent` specifies the number of spaces to use as a single
	  level of indent. Its value is clamped between `0` and `10`
	  inclusively. If it is set to `0`, no line break is inserted and
	  output lines are not indented. It has a default value of `2`.

	* Returns the number of bytes written if the operation succeeds,
	  or `null` otherwise.

### `std.chrono`

`std.chrono.now()`

	* Retrieves the wall clock time.

	* Returns the number of milliseconds since the Unix epoch,
	  `1970-01-01 00:00:00 UTC`, represented as an integer.

`std.chrono.format(time_point, [with_ms], [utc_offset])`

	* Converts `time_point`, which shall be an integer represents the
	  number of milliseconds since `1970-01-01 00:00:00 UTC`, to a
	  string in the modified ISO 8601 format as with Git. Differences
	  are:

	  * a space instead of the T date/time delimiter
	  * a space between time and time zone
	  * no colon between hours and minutes of the timezone

	  If `with_ms` is set to `true`, the string will have a 3-digit
	  decimal part. `utc_offset` can be specified as an integer that
	  represents the number of minutes of local time ahead of UTC
	  time. If `utc_offset` is absent, it is obtained from the local
	  system.

	* Returns a string representing the time point.

`std.chrono.parse(time_str)`

	* Parses `time_str`, which shall be a string representing a time
	  point in the modified ISO 8601 format as results of `format()`.
	  The decimal part is optional and may have fewer or more digits.
	  The timezone part may be `"UTC"` or `"GMT"` for UTC, or an
	  explicit value such as `"+0400"`. If it is absent, the time is
	  assumed to be local. Leading or trailing spaces are allowed.

	* Returns an integer representing the number of milliseconds
	  since `1970-01-01 00:00:00 UTC`.

	* Throws an exception if the string is invalid.

`std.chrono.hires_now()`

	* Retrieves a time point from a high resolution clock. The clock
	  goes monotonically and cannot be adjusted, being suitable for
	  time measurement. This function provides accuracy and might be
	  quite heavyweight.

	* Returns the number of milliseconds since an unspecified time
	  point, represented as a real.

`std.chrono.steady_now()`

	* Retrieves a time point from a steady clock. The clock goes
	  monotonically and cannot be adjusted, being suitable for time
	  measurement. This function is supposed to be fast and might
	  have poor accuracy.

	* Returns the number of milliseconds since an unspecified time
	  point, represented as an integer.

### `std.string`

`std.string.slice(text, from, [length])`

	* Copies a subrange of `text` to create a new byte string. Bytes
	  are copied from `from` if it is non-negative, or from
	  `countof(text) + from` otherwise. If `length` is set to an
	  integer, no more than this number of bytes will be copied. If
	  it is absent, all bytes from `from` to the end of `text` will
	  be copied. If `from` is outside `text`, an empty string is
	  returned.

	* Returns the specified substring of `text`.

`std.string.replace_slice(text, from, [length], replacement, [rfrom, [rlength]])`
	* Replaces a subrange of `text` with `replacement` to create a
	  new byte string. `from` specifies the start of the subrange to
	  replace. If `from` is negative, it specifies an offset from the
	  end of `text`. `length` specifies the maximum number of bytes
	  to replace. If it is set to `null`, all bytes up to the end of
	  `text` are replaced. If `rfrom` is specified, the replacement
	  string is determined as `slice(replacement, rfrom, rlength)`.
	  This function returns a new string without modifying `text`.

	* Returns a string with the subrange replaced.

`std.string.compare(text1, text2, [length])`

	* Performs lexicographical comparison on two byte strings. If
	  `length` is set to an integer, no more than this number of
	  bytes are compared. This function behaves like the `strncmp()`
	  function in C, except that null characters do not terminate
	  strings.

	* Returns a positive integer if `text1` compares greater than
	  `text2`, a negative integer if `text1` compares less than
	  `text2`, or zero if `text1` compares equal to `text2`.

`std.string.starts_with(text, prefix)`

	* Checks whether `prefix` is a prefix of `text`. The empty
	  string is considered to be a prefix of any string.

	* Returns `true` if `prefix` is a prefix of `text`, or `false`
	  otherwise.

`std.string.ends_with(text, suffix)`

	* Checks whether `suffix` is a suffix of `text`. The empty
	  string is considered to be a suffix of any string.

	* Returns `true` if `suffix` is a suffix of `text`, or `false`
	  otherwise.

`std.string.find(text, [from, [length]], pattern)`

	* Searches `text` for the first occurrence of `pattern`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte of the first match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.rfind(text, [from, [length]], pattern)`

	* Searches `text` for the last occurrence of `pattern`.

	* Returns the subscript of the first byte of the last match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.replace(text, [from, [length]], pattern, replacement)`

	* Searches `text` and replaces all occurrences of `pattern` with
	  `replacement`. The search operation is performed on the same
	  subrange that would be returned by `slice(text, from, length)`.
	  This function returns a new string without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

`std.string.find_any_of(text, [from, [length]], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, [from, [length]], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from, length)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, [from, [length]], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, [from, [length]], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.reverse(text)`

	* Reverses a byte string. This function returns a new string
	  without modifying `text`.

	* Returns the reversed string.

`std.string.trim(text, [reject])`

	* Removes the longest prefix and suffix consisting solely bytes
	  from `reject`. If `reject` is empty, no byte is removed. If
	  `reject` is not specified, spaces and tabs are removed. This
	  function returns a new string without modifying `text`.

	* Returns the trimmed string.

`std.string.triml(text, [reject])`

	* Removes the longest prefix consisting solely bytes from
	  `reject`. If `reject` is empty, no byte is removed. If `reject`
	  is not specified, spaces and tabs are removed. This function
	  returns a new string without modifying `text`.

	* Returns the trimmed string.

`std.string.trimr(text, [reject])`

	* Removes the longest suffix consisting solely bytes from
	  `reject`. If `reject` is empty, no byte is removed. If `reject`
	  is not specified, spaces and tabs are removed. This function
	  returns a new string without modifying `text`.

	* Returns the trimmed string.

`std.string.padl(text, length, [padding])`

	* Prepends `text` with `padding` repeatedly, until its length
	  would exceed `length`. The default value of `padding` is a
	  string consisting of a space. This function returns a new
	  string without modifying `text`.

	* Returns the padded string.

	* Throws an exception if `padding` is empty.

`std.string.padr(text, length, [padding])`

	* Appends `text` with `padding` repeatedly, until its length
	  would exceed `length`. The default value of `padding` is a
	  string consisting of a space. This function returns a new
	  string without modifying `text`.

	* Returns the padded string.

	* Throws an exception if `padding` is empty.

`std.string.to_upper(text)`

	* Converts all lowercase English letters in `text` to their
	  uppercase counterparts. This function returns a new string
	  without modifying `text`.

	* Returns a new string after the conversion.

`std.string.to_lower(text)`

	* Converts all uppercase English letters in `text` to their
	  lowercase counterparts. This function returns a new string
	  without modifying `text`.

	* Returns a new string after the conversion.

`std.string.translate(text, inputs, [outputs])`

	* Performs bytewise translation on the given string. For every
	  byte in `text` that is also found in `inputs`, if there is a
	  corresponding replacement byte in `outputs` with the same
	  subscript, it is replaced with the latter; if no replacement
	  exists, because `outputs` is shorter than `inputs` or is null,
	  it is deleted. If `outputs` is longer than `inputs`, excess
	  bytes are ignored. Bytes that do not exist in `inputs` are left
	  intact. This function returns a new string without modifying
	  `text`.

	* Returns the translated string.

`std.string.explode(text, [delim, [limit]])`

	* Breaks `text` down into segments, separated by `delim`. If
	  `delim` is `null` or an empty string, every byte becomes a
	  segment. If `limit` is set to a positive integer, there will be
	  no more segments than this number; the vert last segment will
	  contain all the remaining bytes of the `text`.

	* Returns an array containing the broken-down segments. If `text`
	  is empty, an empty array is returned.

	* Throws an exception if `limit` is negative or zero.

`std.string.implode(segments, [delim])`

	* Concatenates elements of an array, `segments`, to create a new
	  string. All segments shall be strings. If `delim` is
	  specified, it is inserted between adjacent segments.

	* Returns a string containing all segments. If `segments` is
	  empty, an empty string is returned.

`std.string.hex_encode(data, [delim])`

	* Encodes all bytes in `data` as 2-digit hexadecimal numbers and
	  concatenates them. If `delim` is set to a string, it is
	  inserted between adjacent bytes. Hexadecimal digits above nine
	  are encoded as capital letters.

	* Returns the encoded string. If `data` is empty, an empty
	  string is returned.

`std.string.hex_decode(text)`

	* Decodes all hexadecimal digits from `text` and converts them to
	  bytes. Whitespaces can be used to delimit bytes; they shall not
	  occur between digits in the same byte. Consequently, the total
	  number of non-whitespace characters must be a multiple of two.
	  Invalid characters cause decode errors.

	* Returns a string containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty string is returned.

	* Throws an exception if the string is invalid.

`std.string.base32_encode(data)`

	* Encodes all bytes in `data` according to the base32 encoding
	  specified by IETF RFC 4648. Hexadecimal digits above nine are
	  encoded as capital letters. The length of encoded data is
	  always a multiple of 8; padding characters are mandatory.

	* Returns the encoded string.

`std.string.base32_decode(text)`

	* Decodes data encoded in base32, as specified by IETF RFC 4648.
	  Whitespaces can be used to delimit encoding units; they shall
	  not occur between characters in the same unit. Consequently,
	  the number of non-whitespace characters must be a multiple of
	  eight. Invalid characters cause decode errors.

	* Returns a string containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty string is returned.

	* Throws an exception if the string is invalid.

`std.string.base64_encode(data)`

	* Encodes all bytes in `data` according to the base64 encoding
	  specified by IETF RFC 4648. The length of encoded data is
	  always a multiple of 4; padding characters are mandatory.

	* Returns the encoded string.

`std.string.base64_decode(text)`

	* Decodes data encoded in base64, as specified by IETF RFC 4648.
	  Whitespaces can be used to delimit encoding units; they shall
	  not occur between characters in the same unit. Consequently,
	  the number of non-whitespace characters must be a multiple of
	  four. Invalid characters cause decode errors.

	* Returns a string containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty string is returned.

	* Throws an exception if the string is invalid.

`std.string.url_encode(data)`

	* Encodes bytes in `data` according to IETF RFC 3986. Every byte
	  that is not a letter, digit, `-`, `.`, `_` or `~` is encoded as
	  a `%` followed by two hexadecimal digits. Hexadecimal digits
	  above nine are encoded as capital letters.

	* Returns the encoded string. If `data` is empty, an empty
	  string is returned.

`std.string.url_decode(text)`

	* Decodes percent-encode sequences from `text` and converts them
	  to bytes according to IETF RFC 3986. For convenience reasons,
	  both reserved and unreserved characters are copied verbatim.
	  Characters that are neither reserved nor unreserved (such as
	  ASCII control characters or non-ASCII characters) cause decode
	  errors.

	* Returns a string containing decoded bytes.

	* Throws an exception if the string contains invalid characters.

`std.string.url_query_encode(data)`

	* Encodes bytes in `data` according to IETF RFC 3986. This
	  function behaves like `url_encode()`, except that characters
	  that are allowed unencoded in query strings are not encoded,
	  and spaces are encoded as `+` instead of the long form `%20`.

	* Returns the encoded string. If `data` is empty, an empty
	  string is returned.

`std.string.url_decode_query(text)`

	* Decodes percent-encode sequences from `text` and converts them
	  to bytes according to IETF RFC 3986. This function behaves like
	  `url_decode()`, except that `+` is decoded as a space.

	* Returns a string containing decoded bytes.

	* Throws an exception if the string contains invalid characters.

`std.string.utf8_validate(text)`

	* Checks whether `text` is a valid UTF-8 string.

	* Returns `true` if `text` is valid, or `false` otherwise.

`std.string.utf8_encode(code_points, [permissive])`

	* Encodes code points from `code_points` into an UTF-8 string.
	  `code_points` can be either an integer or an array of
	  integers. When an invalid code point is encountered, if
	  `permissive` is set to `true`, it is replaced with the
	  replacement character `"\uFFFD"` and consequently encoded as
	  `"\xEF\xBF\xBD"`; otherwise this function fails.

	* Returns the encoded string.

	* Throws an exception on failure.

`std.string.utf8_decode(text, [permissive])`

	* Decodes `text`, which is expected to be a string containing
	  UTF-8 code units, into an array of code points, represented as
	  integers. When an invalid code sequence is encountered, if
	  `permissive` is set to `true`, all code units of it are
	  re-interpreted as isolated bytes according to ISO/IEC 8859-1;
	  otherwise this function fails.

	* Returns an array containing decoded code points.

	* Throws an exception on failure.

`std.string.format(templ, ...)`

	* Compose a string according to the template string `templ`, as
	  follows:

	  * A sequence of `$$` is replaced with a literal `$`.
	  * A sequence of `${NNN}`, where `NNN` is at most three decimal
	    numerals, is replaced with the NNN-th argument. If `NNN` is
	    zero, it is replaced with `templ` itself.
	  * A sequence of `$N`, where `N` is a single decimal numeral,
	    behaves the same as `${N}`.
	  * All other characters are copied verbatim.

	* Returns the composed string.

	* Throws an exception if `templ` contains invalid placeholder
	  sequences, or when a placeholder sequence has no corresponding
	  argument.

`std.string.PCRE(pattern, [options])`

	* Constructs a string matcher from the Perl-compatible regular
	  expression (PCRE) `pattern`. If `options` is set, it shall be
	  an array of strings, each of whose elements specifies an option
	  for the regular expression (this list is partly copied from the
	  PCRE2 manual):

	  * `"caseless"`    Do caseless matching
	  * `"dotall"`      `.` matches anything including new lines
	  * `"extended"`    Ignore white space and `#` comments
	  * `"multiline"`   `^` and `$` match newlines within data

	* Returns a matcher as an object consisting of the following
	  members:

	  * `find(text, [from, [length]])`
	  * `match(text, [from, [length]])`
	  * `named_match(text, [from, [length]])`
	  * `replace(text, [from, [length]], replacement)`

	  These functions behave the same way as their counterparts with
	  the `pcre_` prefix, as described in this document.

	* Throws an exception if `pattern` is not a valid PCRE.

`std.string.pcre_find(text, [from, [length]], pattern, [options])`

	* Searches `text` for the first match of the Perl-compatible
	  regular expression (PCRE) `pattern`. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(text, from, length)`. `options` specifies options passed
	  to `PCRE(pattern, options)`.

	* Returns an array of two integers. The first integer specifies
	  the subscript of the matching sequence and the second integer
	  specifies its length. If `pattern` is not found, this function
	  returns `null`.

	* Throws an exception if `pattern` is not a valid PCRE.

`std.string.pcre_match(text, [from, [length]], pattern, [options])`

	* Searches `text` for the first match of the Perl-compatible
	  regular expression (PCRE) `pattern`. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(text, from, length)`. `options` specifies options passed
	  to `PCRE(pattern, options)`.

	* Returns an array of strings. The first element is a copy of the
	  substring that matches `pattern`. The remaining elements are
	  substrings that match positional capturing groups. If a group
	  fails to match, its corresponding element is `null`. If `text`
	  does not match `pattern`, `null` is returned.

	* Throws an exception if `pattern` is not a valid PCRE.

`std.string.pcre_named_match(text, [from, [length]], pattern, [options])`

	* Searches `text` for the first match of the Perl-compatible
	  regular expression (PCRE) `pattern`. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(text, from, length)`. `options` specifies options passed
	  to `PCRE(pattern, options)`.

	* Returns an object of all named groups. Each key is the name of
	  a group and its value is the matched substring. If there are no
	  named groups in `pattern`, an empty object is returned. If a
	  group fails to match, its corresponding value is an explicit
	  `null`. If `text` does not match `pattern`, `null` is returned.

	* Throws an exception if `pattern` is not a valid PCRE.

`std.string.pcre_replace(text, [from, [length]], pattern, replacement, [options])`

	* Searches `text` and replaces all matches of the Perl-compatible
	  regular expression (PCRE) `pattern` with `replacement`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`. `options` specifies
	  options passed to `PCRE(pattern, options)`. This function
	  returns a new string without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

	* Throws an exception if `pattern` is not a valid PCRE.

`std.string.iconv(to_encoding, text, [from_encoding])`

	* Converts `text` from `from_encoding` to `to_encoding`. This
	  function is a wrapper for the operating system's iconv library,
	  and accepts the same set of encoding names. If `from_encoding`
	  is absent, `"UTF-8"` is assumed.

	* Returns the converted text as a bytes string.

	* Throws an exception in case of invalid encodings or invalid
	  input string.

### `std.array`

`std.array.slice(data, from, [length])`

	* Copies a subrange of `data` to create a new array. Elements are
	  copied from `from` if it is non-negative, or from
	  `countof(data) + from` otherwise. If `length` is set to an
	  integer, no more than this number of elements will be copied.
	  If it is absent, all elements from `from` to the end of `data`
	  will be copied. If `from` is outside `data`, an empty array
	  is returned.

	* Returns the specified subarray of `data`.

`std.array.replace_slice(data, from, [length], replacement, [rfrom, [rlength]])`

	* Replaces a subrange of `data` with `replacement` to create a
	  new array. `from` specifies the start of the subrange to
	  replace. If `from` is negative, it specifies an offset from the
	  end of `data`. `length` denotes the maximum number of elements
	  to replace. If it is set to `null`, all elements up to the end
	  are replaced. If `rfrom` is specified, the replacement array is
	  determined as `slice(replacement, rfrom, rlength)`. This
	  function returns a new array without modifying `data`.

	* Returns a new array with the subrange replaced.

`std.array.find(data, [from, [length]], [target])`

	* Searches `data` for the first element `x`, for which either
	  `target` is a function and `target(x)` is true, or `target` is
	  not a function and `x == target` is true. The search operation
	  is performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.find_not(data, [from, [length]], [target])`

	* Searches `data` for the first element `x`, for which either
	  `target` is a function and `target(x)` is false, or `target` is
	  not a function and `x == target` is false. The search operation
	  is performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.rfind(data, [from, [length]], [target])`

	* Searches `data` for the last element `x`, for which either
	  `target` is a function and `target(x)` is true, or `target` is
	  not a function and `x == target` is true. The search operation
	  is performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.rfind_not(data, [from, [length]], [target])`

	* Searches `data` for the last element `x`, for which either
	  `target` is a function and `target(x)` is false, or `target` is
	  not a function and `x == target` is false. The search operation
	  is performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.count(data, [from, [length]], [target])`

	* Searches `data` for every element `x`, for which either
	  `target` is a function and `target(x)` is true, or `target` is
	  not a function and `x == target` is true, then returns the
	  number of such elements. The search operation is performed on
	  the same subrange that would be returned by `slice(data, from,
	  length)`.

	* Returns the number of such elements as an integer, which is
	  always non-negative.

`std.array.count_not(data, [from, [length]], predictor)`

	* Searches `data` for every element `x`, for which either
	  `target` is a function and `target(x)` is false, or `target` is
	  not a function and `x == target` is false, then returns the
	  number of such elements. The search operation is performed on
	  the same subrange that would be returned by `slice(data, from,
	  length)`.

	* Returns the number of such elements as an integer, which is
	  always non-negative.

`std.array.exclude(data, [from, [length]], [target])`

	* Removes every element `x`, for which either `target` is a
	  function and `target(x)` is true, or `target` is not a function
	  and `x == target` is true. The search operation is performed on
	  the same subrange that would be returned by `slice(data, from,
	  length)`. This function returns a new array without modifying
	  `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude_if(data, [from, [length]], predictor)`

	* Removes every element `x`, for which either `target` is a
	  function and `target(x)` is false, or `target` is not a
	  function and `x == target` is false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`. This function returns a new array
	  without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.is_sorted(data, [comparator])`

	* Checks whether `data` is sorted. That is, there is no pair of
	  adjacent elements in `data` such that the first one is greater
	  than or unordered with the second one. Elements are compared
	  using `comparator`, which shall be a binary function that
	  returns a negative integer or real if the first argument is
	  less than the second one, a positive integer or real if the
	  first argument is greater than the second one, or `0` if the
	  arguments are equal; other values indicate that the arguments
	  are unordered. If no `comparator` is provided, the built-in
	  3-way comparison operator is used. An array that contains no
	  elements is considered to have been sorted.

	* Returns `true` if `data` is sorted or empty, or `false`
	  otherwise.

`std.array.binary_search(data, [target], [comparator])`

	* Finds the first element in `data` that is equal to `target`.
	  The principle of user-defined `comparator`s is the same as the
	  `is_sorted()` function. As a consequence, the function call
	  `is_sorted(data, comparator)` shall yield `true` prior to this
	  call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.lower_bound(data, [target], [comparator])`

	* Finds the first element in `data` that is greater than or equal
	  to `target` and precedes all elements that are less than
	  `target` if any. The principle of user-defined `comparator`s is
	  the same as the `is_sorted()` function. As a consequence, the
	  function call `is_sorted(data, comparator)` shall yield `true`
	  prior to this call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an integer. This
	  function returns `countof(data)` if all elements are less than
	  `target`.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.upper_bound(data, [target], [comparator])`

	* Finds the first element in `data` that is greater than `target`
	  and precedes all elements that are less than or equal to
	  `target` if any. The principle of user-defined `comparator`s is
	  the same as the `is_sorted()` function. As a consequence, the
	  function call `is_sorted(data, comparator)` shall yield `true`
	  prior to this call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an integer. This
	  function returns `countof(data)` if all elements are less than
	  or equal to `target`.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.equal_range(data, [target], [comparator])`

	* Gets the range of elements equivalent to `target` in `data` as
	  a single function call. This function is equivalent to calling
	  `lower_bound(data, target, comparator)` and
	  `upper_bound(data, target, comparator)` respectively then
	  storing the start and length in an array.

	* Returns an array of two integers, the first of which specifies
	  the lower bound and the second of which specifies the number
	  of elements in the range.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.sort(data, [comparator])`

	* Sorts elements in `data` in ascending order. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. The algorithm shall finish in `O(n log n)` time where
	  `n` is the number of elements in `data`, and shall be stable.
	  This function returns a new array without modifying `data`.

	* Returns the sorted array.

	* Throws an exception if any elements are unordered. Be advised
	  that in this case there is no guarantee whether an exception
	  will be thrown or not.

`std.array.sortu(data, [comparator])`

	* Sorts elements in `data` in ascending order, then removes all
	  elements that have preceding equivalents. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. The algorithm shall finish in `O(n log n)` time where
	  `n` is the number of elements in `data`. This function returns
	  a new array without modifying `data`.

	* Returns the sorted array with no duplicate elements.

	* Throws an exception if any elements are unordered. Be advised
	  that in this case there is no guarantee whether an exception
	  will be thrown or not.

`std.array.ksort(object, [comparator])`

	* Creates an array by sorting elements in `object` by key, as if
	  this function was defined as

	  ```
	  std.array.ksort = func(object, comparator) {
	    var pairs = [];
	    for(each k, v -> object)
	      pairs[$] = [k, v];
	    return this.sort(pairs,
	      func(x, y) {
	        return (comparator == null)
	          ? x[0] <=> y[0]
	          : comparator(x[0], y[0]);
	      });
	  };
	  ```

	* Returns a new array of sorted key-value pairs as nested arrays
	  of two elements.

`std.array.max_of(data, [comparator])`

	* Finds the maximum element in `data`. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. Elements that are unordered with the first element
	  are ignored silently.

	* Returns a copy of the maximum element, or `null` if `data` is
	  empty.

`std.array.min_of(data, [comparator])`

	* Finds the minimum element in `data`. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. Elements that are unordered with the first element
	  are ignored silently.

	* Returns a copy of the minimum element, or `null` if `data` is
	  empty.

`std.array.reverse(data)`

	* Reverses an array. This function returns a new array without
	  modifying `data`.

	* Returns the reversed array.

`std.array.generate(generator, length)`

	* Calls `generator` repeatedly up to `length` times and returns
	  an array consisting of all values returned. `generator` shall
	  be a binary function. The first argument will be the number of
	  elements having been generated; the second argument is the
	  previous element generated, or `null` in the case of the first
	  element.

	* Returns an array containing all values generated.

`std.array.shuffle(data, [seed])`

	* Shuffles elements in `data` randomly. If `seed` is set to an
	  integer, the internal pseudo random number generator will be
	  initialized with it and will produce the same series of numbers
	  for a specific `seed` value. If it is absent, an unspecified
	  seed is generated when this function is called. This function
	  returns a new array without modifying `data`.

	* Returns the shuffled array.

`std.array.rotate(data, shift)`

	* Rotates elements in `data` by `shift`. That is, unless `data`
	  is empty, the element at subscript `x` is moved to subscript
	  `(x + shift) % countof(data)`. No element is added or removed.

	* Returns the rotated array. If `data` is empty, an empty array
	  is returned.

`std.array.copy_keys(source)`

	* Copies all keys from `source`, which shall be an object, to
	  create an array.

	* Returns an array of all keys in `source`.

`std.array.copy_values(source)`

	* Copies all values from `source`, which shall be an object, to
	  create an array.

	* Returns an array of all values in `source`.

### `std.numeric`

`std.numeric.integer_max`

	* Denotes the maximum value of an integer; that is, the value
	  `+0x7FFFFFFFFFFFFFFF`.

`std.numeric.integer_min`

	* Denotes the minimum value of an integer; that is, the value
	  `-0x8000000000000000`.

`std.numeric.real_max`

	* Denotes the maximum finite value of a real; that is, the
	  value `+0x1FFFFFFFFFFFFFp+1023`.

`std.numeric.real_min`

	* Denotes the minimum finite value of a real; that is, the
	  value `-0x1FFFFFFFFFFFFFp+1023`.

`std.numeric.real_epsilon`

	* Denotes the minimum finite value of a real such that
	  `1 + real_epsilon > 1`; that is, `+0x1p-52`.

`std.numeric.size_max`

	* Denotes the maximum length of a string or array. This value is
	  implementation-dependent. Please be advised that there is no
	  guarantee that allocation of a string containing this number
	  of bytes will actually succeed or not.

`std.numeric.abs(value)`

	* Gets the absolute value of `value`, which may be an integer or
	  real. Negative integers are negated, which might cause an
	  exception to be thrown due to overflow. Sign bits of reals are
	  removed, which works on infinities and NaNs and does not
	  result in exceptions.

	* Return the absolute value.

	* Throws an exception if `value` is the integer `-0x1p63`.

`std.numeric.sign(value)`

	* Propagates the sign bit of the number `value`, which may be an
	  integer or real, to all bits of an integer. Be advised that
	  `-0.0` is distinct from `0.0` despite the equality.

	* Returns `-1` if `value` is negative, or `0` otherwise.

`std.numeric.is_finite(value)`

	* Checks whether `value` is a finite number. `value` may be an
	  integer or real. Be adviced that this functions returns `true`
	  for integers for consistency; integers do not support
	  infinities or NaNs.

	* Returns `true` if `value` is an integer or is a real that
	  is neither an infinity or a NaN, or `false` otherwise.

`std.numeric.is_infinity(value)`

	* Checks whether `value` is an infinity. `value` may be an
	  integer or real. Be adviced that this functions returns `false`
	  for integers for consistency; integers do not support
	  infinities.

	* Returns `true` if `value` is a real that denotes an infinity;
	  or `false` otherwise.

`std.numeric.is_nan(value)`

	* Checks whether `value` is a NaN. `value` may be an integer or
	  real. Be adviced that this functions returns `false` for
	  integers for consistency; integers do not support NaNs.

	* Returns `true` if `value` is a real denoting a NaN, or
	  `false` otherwise.

`std.numeric.max(...)`

	* Gets the maximum of all arguments. Null arguments are ignored.

	* Returns the first maximum argument verbatim. If no argument is
	  given, `null` is returned.

	* Throws an exception if some arguments compare unordered.

`std.numeric.min(...)`

	* Gets the minimum of all arguments. Null arguments are ignored.

	* Returns the first minimum argument verbatim. If no argument is
	  given, `null` is returned.

	* Throws an exception if some arguments compare unordered.

`std.numeric.clamp(value, lower, upper)`

	* Limits `value` between `lower` and `upper`.

	* Returns `lower` if `value < lower`, `upper` if `value > upper`,
	  or `value` otherwise, including when `value` is a NaN. The
	  returned value is an integer if all arguments are integers;
	  otherwise it is a real.

	* Throws an exception if `lower` is not less than or equal to
	  `upper`.

`std.numeric.round(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer; halfway values are rounded away from zero. If `value`
	  is an integer, it is returned intact.

	* Returns the rounded value.

`std.numeric.iround(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer; halfway values are rounded away from zero. If `value`
	  is an integer, it is returned intact. If `value` is a real, it
	  is converted to an integer.

	* Returns the rounded value as an integer.

	* Throws an exception if the result cannot be represented as an
	  integer.

`std.numeric.floor(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards negative infinity. If `value` is an integer, it
	  is returned intact.

	* Returns the rounded value.

`std.numeric.ifloor(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards negative infinity. If `value` is an integer, it
	  is returned intact. If `value` is a real, it is converted to an
	  integer.

	* Returns the rounded value as an integer.

	* Throws an exception if the result cannot be represented as an
	  integer.

`std.numeric.ceil(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards positive infinity. If `value` is an integer,
	  it is returned intact.

	* Returns the rounded value.

`std.numeric.iceil(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards positive infinity. If `value` is an integer, it
	  is returned intact. If `value` is a real, it is converted to an
	  integer.

	* Returns the rounded value as an integer.

	* Throws an exception if the result cannot be represented as an
	  integer.

`std.numeric.trunc(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards zero. If `value` is an integer, it is returned
	  intact.

	* Returns the rounded value.

`std.numeric.itrunc(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards zero. If `value` is an integer, it is returned
	  intact. If `value` is a real, it is converted to an integer.

	* Returns the rounded value as an integer.

	* Throws an exception if the result cannot be represented as an
	  integer.

`std.numeric.random([limit])`

	* Generates a random real value whose sign agrees with `limit`
	  and whose absolute value is less than `limit`. If `limit` is
	  absent, `1` is assumed.

	* Returns a random real value.

	* Throws an exception if `limit` is zero or non-finite.

`std.numeric.remainder(x, y)`

	* Calculates the IEEE floating-point remainder of division of `x`
	  by `y`. The remainder is defined to be `x - q * y` where `q` is
	  the quotient of division of `x` by `y` rounding to nearest.

	* Returns the remainder as a real.

`std.numeric.frexp(x)`

	* Decomposes `x` into normalized fractional and exponent parts
	  such that `x = frac * exp2(exp)` where `frac` and `exp` denote
	  the fraction and the exponent respectively and `frac` is always
	  within the range `[0.5,1.0)`. If `x` is non-finite, `exp` is
	  unspecified.

	* Returns an array having two elements, whose first element is
	  `frac` that is of type real and whose second element is `exp`
	  that is of type integer.

`std.numeric.ldexp(frac, exp)`

	* Composes `frac` and `exp` to make a real number `x`, as if by
	  multiplying `frac` with `exp2(exp)`. `exp` must be an integer.
	  This function is the inverse of `frexp()`.

	* Returns the product as a real.

`std.numeric.rotl(m, x, n)`

	* Rotates the rightmost `m` bits of `x` to the left by `n`; all
	  arguments must be of type integer. This has the effect of
	  shifting `x` by `n` to the left then filling the vacuum in the
	  right with the last `n` bits that have just been shifted past
	  the left boundary. `n` is modulo `m` so rotating by a negative
	  count to the left has the same effect as rotating by its
	  absolute value to the right. All other bits are zeroed. If `m`
	  is zero, zero is returned.

	* Returns the rotated value as an integer.

	* Throws an exception if `m` is negative or greater than `64`.

`std.numeric.rotr(m, x, n)`

	* Rotates the rightmost `m` bits of `x` to the right by `n`; all
	  arguments must be of type integer. This has the effect of
	  shifting `x` by `n` to the right then filling the vacuum in the
	  left with the last `n` bits that have just been shifted past
	  the right boundary. `n` is modulo `m` so rotating by a negative
	  count to the right has the same effect as rotating by its
	  absolute value to the left. All other bits are zeroed. If `m`
	  is zero, zero is returned.

	* Returns the rotated value as an integer.

	* Throws an exception if `m` is negative or greater than `64`.

`std.numeric.format(value, [base, [ebase]])`

	* Converts an integer or real number to a string in `base`. This
	  function writes as many digits as possible to ensure precision.
	  No plus sign precedes the significant figures. If `base` is
	  absent, `10` is assumed. If `ebase` is specified, an exponent
	  is appended to the significand as follows: If `value` is of
	  type integer, the significand is kept as short as possible;
	  otherwise (when `value` is of type real), it is written in
	  scientific notation. In both cases, the exponent comprises at
	  least two digits with an explicit sign. If `ebase` is absent,
	  no exponent appears. The result is exact as long as `base` is a
	  power of two.

	* Returns a string converted from `value`.

	* Throws an exception if `base` is neither `2` nor `10` nor `16`,
	  or if `ebase` is not `10` for base-10, or if `ebase` is not `2`
	  for base -2 or base-16.

`std.numeric.parse(text)`

	* Parses `text` for a number. `text` shall be a string. Leading
	  and trailing blank characters are stripped before parsing. If
	  the string becomes empty thereafter, this function fails;
	  otherwise, it shall match one of the following extended
	  regular expressions:

	  * Infinities:
	    `[+-]?infinity`
	  * NaNs:
	    `[+-]?nan`
	  * Binary (base-2):
	    `[+-]?0[bB][01]+(\.[01]+)?([eE][-+]?[0-9]+)?`
	  * Hexadecimal (base-16):
	    `[+-]?0x[0-9a-fA-F]+(\.[0-9a-fA-F]+)?([pP][-+]?[0-9]+)?`
	  * Decimal (base-10):
	    `[+-]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?`

	  If the string does not match any of the above, this function
	  fails. The result is an integer if `text` contains no decimal
	  point and the value is representable as an integer, and is a
	  real otherwise. If the value is outside the range of reals,
	  this function may return signed zeroes or infinities.

	* Returns the numeric value converted from `text`.

	* Throws an exception on failure.

`std.numeric.pack_i8(values)`

	* Packs a series of 8-bit integers into a string. `values` can be
	  either an integer or an array of integers, all of which are
	  truncated to 8 bits then copied into a string.

	* Returns the packed string.

`std.numeric.unpack_i8(text)`

	* Unpacks 8-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 8-bit integers, all of
	  which are sign-extended to 64 bits then copied into an array.

	* Returns an array containing unpacked integers.

`std.numeric.pack_i16be(values)`

	* Packs a series of 16-bit integers into a string. `values` can
	  be either an integer or an array of integers, all of which are
	  truncated to 16 bits then copied into a string big-endian byte
	  order.

	* Returns the packed string.

`std.numeric.unpack_i16be(text)`

	* Unpacks 16-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 16-bit integers in
	  big-endian byte order, all of which are sign-extended to 64
	  bits then copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 2.

`std.numeric.pack_i16le(values)`

	* Packs a series of 16-bit integers into a string. `values` can
	  be either an integer or an array of integers, all of which are
	  truncated to 16 bits then copied into a string in little-endian
	  byte order.

	* Returns the packed string.

`std.numeric.unpack_i16le(text)`

	* Unpacks 16-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 16-bit integers in
	  little-endian byte order, all of which are sign-extended to 64
	  bits then copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 2.

`std.numeric.pack_i32be(values)`

	* Packs a series of 32-bit integers into a string. `values` can
	  be either an integer or an array of integers, all of which are
	  truncated to 32 bits then copied into a string in big-endian
	  byte order.

	* Returns the packed string.

`std.numeric.unpack_i32be(text)`

	* Unpacks 32-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 32-bit integers in
	  big-endian byte order, all of which are sign-extended to 64
	  bits then copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.numeric.pack_i32le(values)`

	* Packs a series of 32-bit integers into a string. `values` can
	  be either an integer or an array of integers, all of which are
	  truncated to 32 bits then copied into a string in little-endian
	  byte order.

	* Returns the packed string.

`std.numeric.unpack_i32le(text)`

	* Unpacks 32-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 32-bit integers in
	  little-endian byte order, all of which are sign-extended to 64
	  bits then copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.numeric.pack_i64be(values)`

	* Packs a series of 64-bit integers into a string. `values` can
	  be either an integer or an array of integers, all of which are
	  copied into a string in big-endian byte order.

	* Returns the packed string.

`std.numeric.unpack_i64be(text)`

	* Unpacks 64-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 64-bit integers in
	  big-endian byte order, all of which are copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

`std.numeric.pack_i64le(values)`

	* Packs a series of 64-bit integers into a string. `values` can
	  be either an integer or an array of integers, all of which
	  are copied into a string in little-endian byte order.

	* Returns the packed string.

`std.numeric.unpack_i64le(text)`

	* Unpacks 64-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 64-bit integers in
	  little-endian byte order, all of which are copied into an
	  array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

`std.numeric.pack_f32be(values)`

	* Packs a series of single-precision floating-point numbers into
	  a string. `values` can be either a real or an array of reals,
	  all of which are copied into a string in big-endian byte order.

	* Returns the packed string.

`std.numeric.unpack_f32be(text)`

	* Unpacks single-precision floating-point numbers from a string.
	  The contents of `text` are re-interpreted as contiguous single-
	  precision floating-point numbers in big-endian byte order, all
	  of which are copied into an array.

	* Returns an array containing unpacked reals.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.numeric.pack_f32le(values)`

	* Packs a series of single-precision floating-point numbers into
	  a string. `values` can be either a real or an array of reals,
	  all of which are copied into a string in little-endian byte
	  order.

	* Returns the packed string.

`std.numeric.unpack_f32le(text)`

	* Unpacks single-precision floating-point numbers from a string.
	  The contents of `text` are re-interpreted as contiguous single-
	  precision floating-point numbers in little-endian byte order,
	  all of which are copied into an array.

	* Returns an array containing unpacked reals.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.numeric.pack_f64be(values)`

	* Packs a series of double-precision floating-point numbers into
	  a string. `values` can be either a real or an array of reals,
	  all of which are copied into a string in big-endian byte order.

	* Returns the packed string.

`std.numeric.unpack_f64be(text)`

	* Unpacks double-precision floating-point numbers from a string.
	  The contents of `text` are re-interpreted as contiguous double-
	  precision floating-point numbers in big-endian byte order, all
	  of which are copied into an array.

	* Returns an array containing unpacked reals.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

`std.numeric.pack_f64le(values)`

	* Packs a series of double-precision floating-point numbers into
	  a string. `values` can be either a real or an array of reals,
	  all of which are copied into a string in little-endian byte
	  order.

	* Returns the packed string.

`std.numeric.unpack_f64le(text)`

	* Unpacks double-precision floating-point numbers from a string.
	  The contents of `text` are re-interpreted as contiguous double-
	  precision floating-point numbers in little-endian byte order,
	  all of which are copied into an array.

	* Returns an array containing unpacked reals.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

### `std.math`

`std.math.pi`

	* Denotes the ratio of a circle's circumference to its diameter
	  as a real. The value is `3.1415926535897932384626433832795`.

`std.math.rad`

	* Denotes the number of degrees in a radian as a real. The value
	  is `57.295779513082320876798154814105`.

`std.math.deg`

	* Denotes the number of radians in a degree as a real. The value
	  is `0.01745329251994329576923690768489`.

`std.math.e`

	* Denotes the base of the natural logarithm as a real. The value
	  is `2.7182818284590452353602874713527`.

`std.math.sqrt2`

	* Denotes the square root of 2 as a real number. The value is
	  `1.4142135623730950488016887242097`.

`std.math.sqrt3`

	* Denotes the square root of 3 as a real number. The value is
	  `1.7320508075688772935274463415059`.

`std.math.cbrt2`

	* Denotes the cube root of 2 as a real number. The value is
	  `1.2599210498948731647672106072782`.

`std.math.lg2`

	* Denotes the common logarithm of 2 as a real number. The value
	  is `0.30102999566398119521373889472449`.

`std.math.lb10`

	* Denotes the binary logarithm of 10 as a real number. The value
	  is `3.3219280948873623478703194294894`.

`std.math.exp([base], y)`

	* Calculates `base` raised to the `y`-th power. The default value
	  of `base` is the constant `e`.

	* Returns the power as a real.

`std.math.log([base], x)`

	* Calculates the logarithm base `base` of `x`. The default value
	  of `base` is the constant `e`.

	* Returns the logarithm as a real.

`std.math.expm1(y)`

	* Calculates `exp(y) - 1` without losing precision when `y` is
	  close to zero.

	* Returns the result as a real.

`std.math.log1p(x)`

	* Calculates `log(1 + x)` without losing precision when `x` is
	  close to zero.

	* Returns the result as a real.

`std.math.sin(x)`

	* Calculates the sine of `x` in radians.

	* Returns the result as a real.

`std.math.cos(x)`

	* Calculates the cosine of `x` in radians.

	* Returns the result as a real.

`std.math.sincos(x)`

	* Calculates the sine and cosine of `x` in radians.

	* Returns an array of two reals. The first element is the sine
	  and the other is the cosine.

`std.math.tan(x)`

	* Calculates the tangent of `x` in radians.

	* Returns the result as a real.

`std.math.asin(x)`

	* Calculates the inverse sine of `x` in radians.

	* Returns the result as a real.

`std.math.acos(x)`

	* Calculates the inverse cosine of `x` in radians.

	* Returns the result as a real.

`std.math.atan(x)`

	* Calculates the inverse tangent of `x` in radians.

	* Returns the result as a real.

`std.math.atan2(y, x)`

	* Calculates the angle of the vector `<x,y>` in radians.

	* Returns the result as a real.

`std.math.hypot(...)`

	* Calculates the length of the n-dimension vector defined by all
	  arguments. If no argument is provided, this function returns
	  zero. If any argument is an infinity, this function returns a
	  positive infinity; otherwise, if any argument is a NaN, this
	  function returns a NaN. Null arguments are ignored.

	* Returns the length as a real.

`std.math.sinh(x)`

	* Calculates the hyperbolic sine of `x`.

	* Returns the result as a real.

`std.math.cosh(x)`

	* Calculates the hyperbolic cosine of `x`.

	* Returns the result as a real.

`std.math.tanh(x)`

	* Calculates the hyperbolic tangent of `x`.

	* Returns the result as a real.

`std.math.asinh(x)`

	* Calculates the inverse hyperbolic sine of `x`.

	* Returns the result as a real.

`std.math.acosh(x)`

	* Calculates the inverse hyperbolic cosine of `x`.

	* Returns the result as a real.

`std.math.atanh(x)`

	* Calculates the inverse hyperbolic tangent of `x`.

	* Returns the result as a real.

`std.math.erf(x)`

	* Calculates the error function of `x`.

	* Returns the result as a real.

`std.math.cerf(x)`

	* Calculates the complementary error function of `x`.

	* Returns the result as a real.

`std.math.gamma(x)`

	* Calculates the Gamma function of `x`.

	* Returns the result as a real.

`std.math.lgamma(x)`

	* Calculates the natural logarithm of the absolute value of the
	  Gamma function of `x`.

	* Returns the result as a real.

### `std.filesystem`

`std.filesystem.get_working_directory()`

	* Gets the absolute path of the current working directory.

	* Returns a string containing the path to the current working
	  directory.

`std.filesystem.get_real_path(path)`

	* Converts `path` to an absolute one. The result is a canonical
	  path that contains no symbolic links. The path must be valid
	  and accessible.

	* Returns a string denoting the absolute path.

	* Throws an exception if `path` is invalid or inaccessible.

`std.filesystem.get_properties(path)`

	* Retrieves properties of the file or directory that is denoted
	  by `path`.

	* Returns an object consisting of the following members:

	  * `device`         integer: unique device ID on this machine
	  * `inode`          integer: unique file ID on this device
	  * `link_count`     integer: number of hard links
	  * `is_directory`   boolean: whether this is a directory
	  * `is_symbolic`    boolean: whether this is a symbolic link
	  * `size`           integer: size of contents in bytes
	  * `size_on_disk`   integer: size of storage on disk in bytes
	  * `time_accessed`  integer: timestamp of last access
	  * `time_modified`  integer: timestamp of last modification

	  On failure, `null` is returned.

`std.filesystem.move_from(path_new, path_old)`

	* Moves (renames) the file or directory at `path_old` to
	  `path_new`.

	* Throws an exception on failure.

`std.filesystem.remove_recursive(path)`

	* Removes the file or directory at `path`. If `path` designates a
	  directory, all of its contents are removed recursively.

	* Returns the number of files and directories that have been
	  successfully removed in total. If `path` does not reference an
	  existent file or directory, `0` is returned.

	* Throws an exception if the file or directory at `path` cannot
	  be removed.

`std.filesystem.dir_list(path)`

	* Lists the contents of the directory at `path`.

	* Returns an object containing all entries of the directory at
	  `path`, excluding the special subdirectories '.' and '..'. For
	  each element, its key specifies the filename and the value is
	  an object consisting of the following members:

	  * `inode`          integer: unique file ID on this device
	  * `is_directory`   boolean: whether this is a directory
	  * `is_symbolic`    boolean: whether this is a symbolic link

	* Throws an exception if `path` does not designate a directory,
	  or some other errors occur.

`std.filesystem.dir_create(path)`

	* Creates a directory at `path`. Its parent directory must exist
	  and must be accessible. This function does not fail if either a
	  directory or a symbolic link to a directory already exists on
	  `path`.

	* Returns `1` if a new directory has been created, or `0` if a
	  directory already exists.

	* Throws an exception if `path` designates a non-directory, or
	  some other errors occur.

`std.filesystem.dir_remove(path)`

	* Removes the directory at `path`. The directory must be empty.
	  This function fails if `path` does not designate a directory.

	* Returns `1` if a directory has been removed successfully, or
	  `0` if no such directory exists.

	* Throws an exception if `path` designates a non-directory, or
	  some other errors occur.

`std.filesystem.file_read(path, [offset, [limit]])`

	* Reads the file at `path` in binary mode. The read operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. If
	  `limit` is specified, no more than this number of bytes will be
	  read.

	* Returns the bytes that have been read as a string.

	* Throws an exception if `offset` is negative, or a read error
	  occurs.

`std.filesystem.file_stream(path, callback, [offset, [limit]])`

	* Reads the file at `path` in binary mode and invokes `callback`
	  with the data read repeatedly. `callback` shall be a binary
	  function whose first argument is the absolute offset of the
	  data block that has been read, and whose second argument is the
	  bytes read and stored in a string. Data may be transferred in
	  multiple blocks of variable sizes; the caller shall make no
	  assumption about the number of times that `callback` will be
	  called or the size of each individual block. The read operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. If
	  `limit` is specified, no more than this number of bytes will be
	  read.

	* Returns the number of bytes that have been read and processed
	  as an integer.

	* Throws an exception if `offset` is negative, or a read error
	  occurs.

`std.filesystem.file_write(path, [offset], data)`

	* Writes the file at `path` in binary mode. The write operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. The
	  file is truncated to this length before the write operation;
	  any existent contents after the write point are discarded. This
	  function fails in case of partial writes.

	* Throws an exception if `offset` is negative, or a write error
	  occurs.

`std.filesystem.file_append(path, data, [exclusive])`

	* Writes the file at `path` in binary mode. The write operation
	  starts from the end of the file; existent contents of the file
	  are left intact. If `exclusive` is `true` and a file exists on
	  `path`, this function fails. This function also fails if the
	  data can only be written partially.

	* Throws an exception if `offset` is negative, or a write error
	  occurs.

`std.filesystem.file_copy_from(path_new, path_old)`

	* Copies the file `path_old` to `path_new`. If `path_old` is a
	  symbolic link, it is the target that will be copied, rather
	  than the symbolic link itself. This function fails if
	  `path_old` designates a directory.

	* Throws an exception on failure.

`std.filesystem.file_remove(path)`

	* Removes the file at `path`. This function fails if `path`
	  designates a directory.

	* Returns `1` if a file has been removed successfully, or `0` if
	  no such file exists.

	* Throws an exception if `path` designates a directory, or some
	  other errors occur.

### `std.checksum`

`std.checksum.CRC32()`

	* Creates a CRC-32 hasher according to ISO/IEC 3309. The divisor
	  is `0x04C11DB7` (or `0xEDB88320` in reverse form).

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`
	  * `clear()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as an integer (whose
	  high-order 32 bits are always zeroes), then resets the hasher,
	  making it suitable for further data as if it had just been
	  created. The function `clear()` discards input data and resets
	  the hasher to its initial state.

`std.checksum.crc32(data)`

	* Calculates the CRC-32 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.crc32 = func(data) {
	    var h = this.CRC32();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the CRC-32 checksum as an integer. The high-order 32
	  bits are always zeroes.

`std.checksum.crc32_file(path)`

	* Calculates the CRC-32 checksum of the file denoted by `path`,
	  as if this function was defined as

	  ```
	  std.checksum.crc32_file = func(path) {
	    var h = this.CRC32();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the CRC-32 checksum as an integer. The high-order 32
	  bits are always zeroes.

	* Throws an exception if a read error occurs.

`std.checksum.FNV1a32()`

	* Creates a 32-bit Fowler-Noll-Vo (a.k.a. FNV) hasher of the
	  32-bit FNV-1a variant. The FNV prime is `16777619` and the FNV
	  offset basis is `2166136261`.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`
	  * `clear()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as an integer (whose
	  high-order 32 bits are always zeroes), then resets the hasher,
	  making it suitable for further data as if it had just been
	  created. The function `clear()` discards input data and resets
	  the hasher to its initial state.

`std.checksum.fnv1a32(data)`

	* Calculates the 32-bit FNV-1a checksum of `data` which must be
	  a byte string, as if this function was defined as

	  ```
	  std.checksum.fnv1a32 = func(data) {
	    var h = this.FNV1a32();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the 32-bit FNV-1a checksum as an integer. The
	  high-order 32 bits are always zeroes.

`std.checksum.fnv1a32_file(path)`

	* Calculates the 32-bit FNV-1a checksum of the file denoted by
	  `path`, as if this function was defined as

	  ```
	  std.checksum.fnv1a32_file = func(path) {
	    var h = this.FNV1a32();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the 32-bit FNV-1a checksum as an integer. The
	  high-order 32 bits are always zeroes.

	* Throws an exception if a read error occurs.

`std.checksum.MD5()`

	* Creates an MD5 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`
	  * `clear()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 32
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.
	  The function `clear()` discards all input data and resets the
	  hasher to its initial state.

`std.checksum.md5(data)`

	* Calculates the MD5 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.md5 = func(data) {
	    var h = this.MD5();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the MD5 checksum as a string of 32 hexadecimal digits
	  in uppercase.

`std.checksum.md5_file(path)`

	* Calculates the MD5 checksum of the file denoted by `path`, as
	  if this function was defined as

	  ```
	  std.checksum.md5_file = func(path) {
	    var h = this.MD5();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the MD5 checksum as a string of 32 hexadecimal digits
	  in uppercase.

	* Throws an exception if a read error occurs.

`std.checksum.SHA1()`

	* Creates an SHA-1 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`
	  * `clear()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 40
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.
	  The function `clear()` discards all input data and resets
	  the hasher to its initial state.

`std.checksum.sha1(data)`

	* Calculates the SHA-1 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.sha1 = func(data) {
	    var h = this.SHA1();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-1 checksum as a string of 40 hexadecimal
	  digits in uppercase.

`std.checksum.sha1_file(path)`

	* Calculates the SHA-1 checksum of the file denoted by `path`, as
	  if this function was defined as

	  ```
	  std.checksum.sha1_file = func(path) {
	    var h = this.SHA1();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-1 checksum as a string of 40 hexadecimal digits
	  in uppercase.

	* Throws an exception if a read error occurs.

`std.checksum.SHA224()`

	* Creates an SHA-224 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`
	  * `clear()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 64
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.
	  The function `clear()` discards all input data and resets
	  the hasher to its initial state.

`std.checksum.sha224(data)`

	* Calculates the SHA-224 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.sha224 = func(data) {
	    var h = this.SHA224();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-224 checksum as a string of 64 hexadecimal
	  digits in uppercase.

`std.checksum.sha224_file(path)`

	* Calculates the SHA-224 checksum of the file denoted by `path`,
	  as if this function was defined as

	  ```
	  std.checksum.sha224_file = func(path) {
	    var h = this.SHA224();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-224 checksum as a string of 64 hexadecimal
	  digits in uppercase.

	* Throws an exception if a read error occurs.

`std.checksum.SHA256()`

	* Creates an SHA-256 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`
	  * `clear()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 64
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.
	  The function `clear()` discards all input data and resets
	  the hasher to its initial state.

`std.checksum.sha256(data)`

	* Calculates the SHA-256 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.sha256 = func(data) {
	    var h = this.SHA256();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-256 checksum as a string of 64 hexadecimal
	  digits in uppercase.

`std.checksum.sha256_file(path)`

	* Calculates the SHA-256 checksum of the file denoted by `path`,
	  as if this function was defined as

	  ```
	  std.checksum.sha256_file = func(path) {
	    var h = this.SHA256();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-256 checksum as a string of 64 hexadecimal
	  digits in uppercase.

	* Throws an exception if a read error occurs.

`std.checksum.SHA384()`

	* Creates an SHA-384 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`
	  * `clear()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 64
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.
	  The function `clear()` discards all input data and resets
	  the hasher to its initial state.

`std.checksum.sha384(data)`

	* Calculates the SHA-384 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.sha384 = func(data) {
	    var h = this.SHA384();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-384 checksum as a string of 64 hexadecimal
	  digits in uppercase.

`std.checksum.sha384_file(path)`

	* Calculates the SHA-384 checksum of the file denoted by `path`,
	  as if this function was defined as

	  ```
	  std.checksum.sha384_file = func(path) {
	    var h = this.SHA384();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-384 checksum as a string of 64 hexadecimal
	  digits in uppercase.

	* Throws an exception if a read error occurs.

`std.checksum.SHA512()`

	* Creates an SHA-512 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`
	  * `clear()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 64
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.
	  The function `clear()` discards all input data and resets
	  the hasher to its initial state.

`std.checksum.sha512(data)`

	* Calculates the SHA-512 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.sha512 = func(data) {
	    var h = this.SHA512();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-512 checksum as a string of 64 hexadecimal
	  digits in uppercase.

`std.checksum.sha512_file(path)`

	* Calculates the SHA-512 checksum of the file denoted by `path`,
	  as if this function was defined as

	  ```
	  std.checksum.sha512_file = func(path) {
	    var h = this.SHA512();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-512 checksum as a string of 64 hexadecimal
	  digits in uppercase.

	* Throws an exception if a read error occurs.

### `std.json`

`std.json.format([value], [indent], [json5])`

	* Converts a value to a string in the JSON format, according to
	  IETF RFC 7159. This function generates text that conforms to
	  JSON strictly; values whose types cannot be represented in JSON
	  are discarded if they are found in an object and censored to
	  `null` otherwise. If `indent` is set to a string, it is used as
	  each level of indention following a line break, unless it is
	  empty, in which case no line break is inserted. If `indent` is
	  specified as an integer, it is clamped between `0` and `10`
	  inclusively and this function behaves as if a string consisting
	  of this number of spaces was set. If `json5` is set to `true`,
	  the JSON5 alternative format is used.

	* Returns the formatted text as a string.

`std.json.parse(text)`

	* Parses a string containing data encoded in the JSON format and
	  converts it to a value. This function reuses the tokenizer of
	  Asteria and allows quite a few extensions, some of which are
	  also supported by JSON5:

	  * Single-line and multiple-line comments are allowed.
	  * Binary and hexadecimal numbers are allowed.
	  * Numbers can have binary exponents.
	  * Infinities and NaNs are allowed.
	  * Numbers can start with plus signs.
	  * Strings and object keys may be single-quoted.
	  * Escape sequences (including UTF-32) are allowed in strings.
	  * Element lists of arrays and objects may end in commas.
	  * Object keys may be unquoted if they are valid identifiers.

	  Be advised that numbers are always parsed as reals.

	* Returns the parsed value.

	* Throws an exception if the string is invalid.

`std.json.parse_file(path)`

	* Parses the contents of the file denoted by `path` as a JSON
	  string for a value. This function behaves identically to
	  `parse()` otherwise.

	* Returns the parsed value.

	* Throws an exception if a read error occurs, or if the string is
	  invalid.

### `std.ini`

`std.ini.format(object)`

       * Converts `object` to a string in the INI format. Unlike JSON,
         the INI format is too primitive to support complex structures,
         which limits the domain of convertible values. `object` shall be
         an object of objects where up to two nesting levels are allowed.
         Boolean, integer, real and string values are written in their
         string forms; the others are ignored silently.

       * Returns the formatted text as a string.

`std.ini.parse(text)`

       * Parses a string containing data encoded in the INI format and
         converts it to an object.

       * Returns the parsed value as an object. Each section in the INI
         string corresponds to a subobject, and each key in this section
         corresponds to a string in this subobject. No type conversion is
         performed. Comments may start with either `;` or `#`.

       * Throws an exception if the string is invalid.

`std.ini.parse_file(path)`

       * Parses the contents of the file denoted by `path` as an INI
         string for an object. This function behaves identically to
         `parse()` otherwise.

       * Returns the parsed value as an object.

       * Throws an exception if a read error occurs, or if the string is
         invalid.

### `std.csv`

`std.csv.format(array)`

       * Converts `array` to a string in the CSV format. Unlike JSON,
         the CSV format is too primitive to support complex structures,
         which limits the domain of convertible values. `array` shall be
         an array of arrays, where up to two nesting levels are allowed.
         Boolean, integer, real and string values are written in their
         string forms; the others are ignored silently.

       * Returns the formatted text as a string.

`std.csv.parse(text)`

       * Parses a string containing data encoded in the CSV format and
         converts it to an array.

       * Returns the parsed value as an array. Each section in the CSV
         string corresponds to a subarray, and each key in this section
         corresponds to a string in this subarray. No type conversion is
         performed.

       * Throws an exception if the string is invalid.

`std.csv.parse_file(path)`

       * Parses the contents of the file denoted by `path` as an CSV
         string for an array. This function behaves identically to
         `parse()` otherwise.

       * Returns the parsed value as an array.

       * Throws an exception if a read error occurs, or if the string is
         invalid.

### `std.io`

`std.io.getc()`

	* Reads a UTF code point from standard input.

	* Returns the code point that has been read as an integer. If the
	  end of input is encountered, `null` is returned.

	* Throws an exception if standard input is binary-oriented, or if
	  a read error occurs.

`std.io.getln()`

	* Reads a UTF-8 string from standard input, which is terminated
	  by either a LF character or the end of input. The terminating
	  LF, if any, is not included in the returned string.

	* Returns the line that has been read as a string. If the end of
	  input is encountered, `null` is returned.

	* Throws an exception if standard input is binary-oriented, or if
	  a read error occurs, or if source data cannot be converted to a
	  valid UTF code point sequence.

`std.io.putc(value)`

	* Writes a UTF-8 string to standard output. `value` may be either
	  an integer representing a UTF code point or a UTF-8 string.

	* Returns the number of UTF code points that have been written.

	* Throws an exception if standard output is binary-oriented, or
	  if source data cannot be converted to a valid UTF code point
	  sequence, or if a write error occurs.

`std.io.putln(text)`

	* Writes a UTF-8 string to standard output, followed by a LF,
	  which may flush the stream automatically. `text` shall be a
	  UTF-8 string.

	* Returns the number of UTF code points that have been written,
	  including the terminating LF.

	* Throws an exception if standard output is binary-oriented, or
	  if source data cannot be converted to a valid UTF code point
	  sequence, or if a write error occurs.

`std.io.putf(templ, ...)`

	* Compose a string in the same way as `std.string.format()`, but
	  instead of returning it, write it to standard output.

	* Returns the number of UTF code points that have been written.

	* Throws an exception if standard output is binary-oriented, or
	  if source data cannot be converted to a valid UTF code point
	  sequence, or if a write error occurs.

`std.io.putfln(templ, ...)`

	* Compose a string in the same way as `std.string.format()`, but
	  instead of returning it, write it to standard output, followed
	  by a LF.

	* Returns the number of UTF code points that have been written,
	  including the terminating LF.

	* Throws an exception if standard output is binary-oriented, or
	  if source data cannot be converted to a valid UTF code point
	  sequence, or if a write error occurs.

`std.io.read([limit])`

	* Reads a series of bytes from standard input. If `limit` is set,
	  no more than this number of bytes will be read.

	* Returns the bytes that have been read as a string. If the end
	  of input is encountered, `null` is returned.

	* Throws an exception if standard input is text-oriented, or if
	  a read error occurs, or if source data cannot be converted to a
	  valid UTF code point sequence.

`std.io.write(data)`

	* Writes a series of bytes to standard output. `data` shall be a
	  byte string.

	* Returns the number of bytes that have been written.

	* Throws an exception if standard output is text-oriented, or if
	  a write error occurs.

`std.io.flush()`

	* Forces buffered data on standard output to be delivered to its
	  underlying device. This function may be called regardless of
	  the orientation of standard output.

	* Throws an exception if a write error occurs.

### `std.zlib`

`std.zlib.Deflator(format, [level])`

	* Creates a data compressor using the deflate algorithm according
	  to RFC 1951. `format` must be one of `"deflate"`, `"gzip"`, or
	  `"raw"`. `level` specifies the compression level, which must be
	  an integer within `[1,9]`. If it is absent, a moderate level is
	  selected.

	* Returns a compressor as an object consisting of the following
	  members:

	  * `output`
	  * `update(data)`
	  * `flush()`
	  * `finish()`
	  * `clear()`

	  The string `output` is where compressed data will be appended.
	  The function `update()` puts data into the compressor, which
	  shall be a byte string. The function `flush()` causes pending
	  bits to be pushed into the output string and aligned on a byte
	  boundary. The `finish()` function marks the end of input data
	  and returns a copy of the output string. The function `clear()`
	  discards both input and output data and resets the compressor
	  to its initial state.

	* Throws an exception if `format` is invalid or `level` is out of
	  range.

`std.zlib.deflate(data, [level])`

	* Compresses `data` which must be a byte string, as if this
	  function was defined as

	  ```
	  std.zlib.deflate = func(data, level) {
	    var r = this.Deflator("deflate", level);
	    r.update(data);
	    return r.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the compressed string.

	* Throws an exception if `level` is out of range.

`std.zlib.gzip(data, [level])`

	* Compresses `data` which must be a byte string, as if this
	  function was defined as

	  ```
	  std.zlib.deflate = func(data, level) {
	    var r = this.Deflator("gzip", level);
	    r.update(data);
	    return r.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the compressed string.

	* Throws an exception if `level` is out of range.

`std.zlib.Inflator(format)`

	* Creates a data decompressor which uses the deflate algorithm
	  according to RFC 1951. `format` must be one of `"deflate"`,
	  `"gzip"`,  or `"raw"`.

	* Returns a decompressor as an object consisting of the following
	  members:

	  * `output`
	  * `update(data)`
	  * `flush()`
	  * `finish()`
	  * `clear()`

	  The string `output` is where decompressed data will be pushed.
	  The function `update()` puts data into the decompressor, which
	  shall be a byte string. The function `flush()` causes pending
	  decompressed bytes to be appended to the output string. The
	  `finish()` function marks the end of input data and returns a
	  copy of the output string. The function `clear()` discards both
	  input and output data and then resets the decompressor to its
	  initial state.

	* Throws an exception if `format` is invalid.

`std.zlib.inflate(data)`

	* Decompresses `data` which must be a byte string, as if this
	  function was defined as

	  ```
	  std.zlib.inflate = func(data) {
	    var r = this.Inflator("deflate");
	    r.update(data);
	    return r.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the decompressed string.

	* Throws an exception in case of corrupt input data.

`std.zlib.gunzip(data)`

	* Decompresses `data` which must be a byte string, as if this
	  function was defined as

	  ```
	  std.zlib.gunzip = func(data) {
	    var r = this.Inflator("gzip");
	    r.update(data);
	    return r.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the decompressed string.

	* Throws an exception in case of corrupt input data.
